-- ffi setup 
local ffi = require("ffi")
local C = ffi.C

local Utils = require("extensions.rkn_configio.utils")

local L = {}

local config = {
	stationKey = "station",
	stationLoadoutKey = "station_loadout",
	shipKey = "ship",
	shipLoadoutKey = "ship_loadout",
	folderIdFormat = "rkn_configio.folder.%s.%s",
	settingsBlackboardId = "$RKN_ConfigioSettings",
	autoPresetsBlackboardId = "$RKN_ConfigioAutoPresets"
}

function L.prepareBrowserStructure(itemList)
	-- First we build the folder structure --
	local root = { type = "folder", name = "root", folders = {}, folders_arr = {}, items = {} }
	for _, item in ipairs(itemList) do
		if not L.filterItem(item) then
			goto continue
		end
		local cwd = root
		-- iterate through item folders --
		local nextMatch = string.gmatch(item.name, "[^" .. Utils.EscapeGmatch(L.settings.folder_delimiter) .. "]+")
		local folder = nextMatch()
		local name = item.name
		local levelsLeft = L.settings.folder_enabled and L.params.maxFolders or 0
		local folderPath = ""
		while 1==1 do
			-- Check if this is the item name --
			local next = nextMatch()
			if not next then
				name = folder
				break
			end
			levelsLeft = levelsLeft -1
			if levelsLeft <= 0 then
				-- Make the rest of the actual item name, the displayed name --
				name = item.name:sub(folderPath:len())
				break
			end
			-- Otherwise, path to folder --
			folderPath = folderPath .. "/" .. folder
			local target = cwd.folders[folder]
			if not target then
				target = { type = "folder", name = folder, fullname = folderPath, folders = {}, folders_arr = {}, items = {} }
				cwd.folders[folder] = target
				table.insert(cwd.folders_arr, target)
			end
			cwd = target
			folder = next
		end
		-- Inser item to final folder --
		table.insert(cwd.items, { type = "item", name = name, active = L.params.isItemActive(item), deleteable = item.deleteable, item = item })
		::continue::
	end

	if L.settings.folder_flatten_single_item then
		L.undentSingleItems(root)
	end

	-- Now we sort all folders --
	L.sortFolder(root)

	return root
end

function L.filterItem(item)
	local search = L.state[L.params.settingKey].filter.search
	if search and search ~= "" then
		local searchMatch = item.name:lower():find(search:lower())
		if not searchMatch then
			return false
		end
	end
	if L.settings.item_hide_inactive and not L.params.isItemActive(item) then
		return false
	end
	if L.params.itemFilter and (not L.params.itemFilter(item)) then
		return false
	end
	return true
end

function L.filterItemByModules(item)
	local selectedMacros = L.state[L.params.settingKey].filter.macros
	if selectedMacros and #selectedMacros > 0 then
		local hasmacros = Helper.textArrayHelper(selectedMacros, function (numtexts, texts) return C.CheckConstructionPlanForMacros(item.id, texts, numtexts) end)
		if not hasmacros then
			return false
		end
	end
	return true
end

function L.filterItemByRace(item)
	local makerraces = GetMacroData(item.id, "makerraceid")
	local selectedRaces = L.state[L.params.settingKey].filter.races
	if selectedRaces and next(selectedRaces) ~= nil then
		local f = false
		for k,_ in pairs(selectedRaces) do
			if #makerraces == 0 then
				if k == "other" then
					return true
				end
			else
				for _,r in ipairs(makerraces) do
					if r == k or (r == "xenon" and k == "other") then
						return true
					end
				end
			end
		end
		return false
	end
	return true
end

function L.undentSingleItems(folder, parent)
	local canDelete = true
	local atLeastOneSubFolder = false
	-- recursive --
	Utils.ArrayRemove(folder.folders_arr, function(t, i, j)
		local subfolder = folder.folders_arr[i];
		local keepSubFolder = L.undentSingleItems(subfolder, folder)
		canDelete = canDelete and not keepSubFolder
		atLeastOneSubFolder = atLeastOneSubFolder or keepSubFolder
		return keepSubFolder
	end);

	-- move item to parent if there is only one --
	local itemCount = #folder.items
	if itemCount == 1 and not atLeastOneSubFolder and parent then
		local item = folder.items[1]

		table.insert(parent.items, item)
		table.remove(folder.items, 1)

		item.name = folder.name .. L.settings.folder_delimiter .. item.name
	elseif itemCount > 1 then
		canDelete = false
	end
	return not canDelete
end

function L.sortFolder(folder)
	table.sort(folder.items, function (a, b) return a.name < b.name end)
	table.sort(folder.folders_arr, function (a, b) return a.name < b.name end)
	for _, innerFolder in ipairs(folder.folders_arr) do
		L.sortFolder(innerFolder)
	end
end

function L.getAllWaresByTag(tag)
	-- uint32_t GetNumWares(const char* tags, bool research, const char* licenceownerid, const char* exclusiontags);
	-- uint32_t GetWares(const char** result, uint32_t resultlen, const char* tags, bool research, const char* licenceownerid, const char* exclusiontags);
	local result = {}
	local numwares = C.GetNumWares(tag, false, nil, "noplayerblueprint")
	local wares = ffi.new("const char*[?]", numwares)
	numwares = C.GetWares(wares, numwares, tag, false, nil, "noplayerblueprint")
	for j = 0, numwares - 1 do
		local locware = ffi.string(wares[j])
		table.insert(result, locware)
	end
	return result
end

function L.getAllProductionModules()
	local result = {}
    for _, ware in ipairs(L.getAllWaresByTag("module")) do
        local name, macro = GetWareData(ware, "name", "component")
		local moduletype = GetMacroData(macro, "infolibrary")

		if moduletype == "moduletypes_production" then
			local entry = { name = name, macro = macro }
			table.insert(result, entry)
		end
    end
	
	table.sort(result, function (a, b) return a.name < b.name end)
	return result
end

function L.getAllWeapons()
	local result = {}
    for _, ware in ipairs(L.getAllWaresByTag("weapon")) do
        local name, macro = GetWareData(ware, "name", "component")
		
		local isAlias, librarytype = GetMacroData(macro, "hasinfoalias", "infolibrary")
		if not isAlias and IsKnownItem(librarytype, macro) then
			local entry = { text = name, id = macro, icon = "", displayremoveoption = false }
			table.insert(result, entry)
		end
    end
	
	table.sort(result, function (a, b) return a.text < b.text end)
	return result
end

function L.getAllTurrets()
	local mTurrets = {}
	local lTurrets = {}
    for _, ware in ipairs(L.getAllWaresByTag("turret")) do
        local name, macro = GetWareData(ware, "name", "component")
		
		local isAlias, librarytype = GetMacroData(macro, "hasinfoalias", "infolibrary")
		if not isAlias and IsKnownItem(librarytype, macro) then
			local entry = { text = name, id = macro, icon = "", displayremoveoption = false }
			local _, _, slotsize = macro:find("^%a+_%a+_(%a)_")
			if slotsize then
				if slotsize:lower() == "l" then
					table.insert(lTurrets, entry)
				elseif slotsize:lower() == "m" then
					table.insert(mTurrets, entry)
				end
			end
		end
    end
	
	table.sort(mTurrets, function (a, b) return a.text < b.text end)
	table.sort(lTurrets, function (a, b) return a.text < b.text end)
	return mTurrets, lTurrets
end

function L.getAllShields()
	local mShields = {}
	local lShields = {}
	local xlShields = {}
	local sShields = {}
    for _, ware in ipairs(L.getAllWaresByTag("shield")) do
        local name, macro = GetWareData(ware, "name", "component")
		
		local isAlias, librarytype = GetMacroData(macro, "hasinfoalias", "infolibrary")
		if not isAlias and IsKnownItem(librarytype, macro) then
			local entry = { text = name, id = macro, icon = "", displayremoveoption = false }
			local _, _, type, slotsize = macro:find("^(%a+)_%a+_(%a+)_")
			if slotsize and type ~= "ishield" then -- Ignore VRO internal shields
				if slotsize:lower() == "l" then
					table.insert(lShields, entry)
				elseif slotsize:lower() == "m" then
					table.insert(mShields, entry)
				elseif slotsize:lower() == "xl" then
					table.insert(xlShields, entry)
				elseif slotsize:lower() == "s" then
					table.insert(sShields, entry)
				end
			end
		end
    end
	
	table.sort(sShields, function (a, b) return a.text < b.text end)
	table.sort(mShields, function (a, b) return a.text < b.text end)
	table.sort(lShields, function (a, b) return a.text < b.text end)
	table.sort(xlShields, function (a, b) return a.text < b.text end)
	return sShields, mShields, lShields, xlShields
end

function L.getAllEngines()
	local result = {}
    for _, ware in ipairs(L.getAllWaresByTag("engine")) do
        local name, macro = GetWareData(ware, "name", "component")
		
		local isAlias, librarytype = GetMacroData(macro, "hasinfoalias", "infolibrary")
		if not isAlias and IsKnownItem(librarytype, macro) then
			local entry = { text = name, id = macro, icon = "", displayremoveoption = false }
			table.insert(result, entry)
		end
    end
	
	table.sort(result, function (a, b) return a.text < b.text end)
	return result
end

function L.getAllThrusters()
	local result = {}
    for _, ware in ipairs(L.getAllWaresByTag("thruster")) do
        local name, macro = GetWareData(ware, "name", "component")
		
		local isAlias, librarytype = GetMacroData(macro, "hasinfoalias", "infolibrary")
		if not isAlias and IsKnownItem(librarytype, macro) then
			local entry = { text = name, id = macro, icon = "", displayremoveoption = false }
			table.insert(result, entry)
		end
    end
	
	table.sort(result, function (a, b) return a.text < b.text end)
	return result
end

function L.getAllRaces(skip)
	local races = {}
	local n = C.GetNumAllRaces()
	local buf = ffi.new("RaceInfo[?]", n)
	n = C.GetAllRaces(buf, n)
	for i = 0, n - 1 do
		local entry = {}
		entry.id = ffi.string(buf[i].id)
		entry.name = ffi.string(buf[i].name)

		if not skip[entry.id] then
			table.insert(races, entry)
		end
	end
	return races
end

function L.getAllShipFilterRaces()
	local skip = { khaak = true, drone = true, xenon = true }
	local races = L.getAllRaces(skip)
	table.sort(races, function (a, b) return a.name < b.name end)
	table.insert(races, { name = "Other", id = "other" })
	return races
end

function L.getAllAutoPresetRaces()
	local skip = { khaak = true, drone = true, xenon = true }
	local races = L.getAllRaces(skip)
	table.sort(races, function (a, b) return a.name < b.name end)
	return races
end

function L.getLoadSettings()
	local default = {
		folder_enabled = false,
		folder_delimiter = "/",
		folder_flatten_single_item = false,
		folder_fullname = false,
		item_fullname = true,
		item_hide_inactive = false,
		item_load_partial = false,
		enabled = true,
	}
	local allDefault = {
		[config.stationKey] = Utils.ShallowCopy(default),
		[config.stationLoadoutKey] = Utils.ShallowCopy(default),
		[config.shipKey] = Utils.ShallowCopy(default),
		[config.shipLoadoutKey] = Utils.ShallowCopy(default)
	}
	if not L.playerID then
		return allDefault
	end
	local all = GetNPCBlackboard(L.playerID, config.settingsBlackboardId)
	if not all then
		return allDefault
	end
	local r = {
		[config.stationKey] = L.convertLoadSettings(all[config.stationKey], default),
		[config.stationLoadoutKey] = L.convertLoadSettings(all[config.stationLoadoutKey], default),
		[config.shipKey] = L.convertLoadSettings(all[config.shipKey], default),
		[config.shipLoadoutKey] = L.convertLoadSettings(all[config.shipLoadoutKey], default)
	}
	return r
end

function L.convertLoadSettings(s, default)
	if not s then
		return default
	end
	local r = {}
	for k,d in pairs(default) do
		local l = s[k]
		if type(d) == "boolean" then
			l = l == nil and d or l == 1
		end
		if k == "folder_delimiter" and l == "" then
			l = "/"
		end
		r[k] = l
	end
	return r
end

function L.setLoadSetting(configKey, key, value)
	local settings = L.getLoadSettings()
	settings[configKey][key] = value
	SetNPCBlackboard(L.playerID, config.settingsBlackboardId, settings)
end

function L.addCustomAutoPresets(key, loadouts)
	local autoPresets = L.getAutoPresets(key)
	if next(autoPresets) ~= nil then
		for id, preset in pairs(autoPresets) do
			table.insert(loadouts, { customPreset = preset, id = id, name = preset.name, deleteable = true, active = true })
		end
	end
	return loadouts
end

function L.getAutoPresetByName(autoPresets, name)
	for id, preset in pairs(autoPresets) do
		if preset.name == name then
			return preset
		end
	end
	return nil
end

function L.getAutoPresets(key)
	local autoPresets = GetNPCBlackboard(L.playerID, config.autoPresetsBlackboardId)
	if autoPresets then
		return autoPresets[key] or {}
	end
	return {}
end

function L.saveAutoPreset(preset, id)
	if not preset or not preset.name or preset.name == "" then
		return
	end
	local autoPresets = GetNPCBlackboard(L.playerID, config.autoPresetsBlackboardId)
	if not autoPresets then
		autoPresets = { idCounter = 0 }
	end
	local autoPresetsForKey = autoPresets[L.params.settingKey]
	if not autoPresetsForKey then
		autoPresetsForKey = {}
		autoPresets[L.params.settingKey] = autoPresetsForKey
	end
	if not id then
		id = autoPresets.idCounter + 1
		autoPresets.idCounter = id
		preset.id = id
	end
	autoPresetsForKey["rknconfigio_auto_" .. tostring(id)] = preset
	SetNPCBlackboard(L.playerID, config.autoPresetsBlackboardId, autoPresets)
end

function L.generateLoadoutUpgradePlan(menu, presetTemplate)
	local upgradeplan = {
		drone = { },
		thruster = { },
		shield = { },
		engine = { },
		deployable = { },
		crew = { },
		turret = { },
		turretgroup = { },
		software = { },
		shieldgroup = { },
		countermeasure = { },
		missile = { },
		enginegroup = { },
		weapon = { }
	}

	for _, group in ipairs(menu.groups) do
		if #group.turret.possiblemacros > 0 then
			local chosenMacro
			if group.turret.slotsize == "medium" then
				chosenMacro = L.chooseMacroByRules(menu, group.turret.possiblemacros, presetTemplate.mturrets)
			elseif group.turret.slotsize == "large" then
				chosenMacro = L.chooseMacroByRules(menu, group.turret.possiblemacros, presetTemplate.lturrets)
			end
			if chosenMacro then
				table.insert(upgradeplan.turretgroup, { path = group.path, group = group.group, count = group.turret.total, macro = chosenMacro })
			end
		end
		if #group.shield.possiblemacros > 0 then
			local chosenMacro
			if group.shield.slotsize == "medium" then
				chosenMacro = L.chooseMacroByRules(menu, group.shield.possiblemacros, presetTemplate.mshields)
			elseif group.shield.slotsize == "large" then
				chosenMacro = L.chooseMacroByRules(menu, group.shield.possiblemacros, presetTemplate.lshields)
			elseif group.shield.slotsize == "extralarge" then
				chosenMacro = L.chooseMacroByRules(menu, group.shield.possiblemacros, presetTemplate.xlshields)
			end
			if chosenMacro then
				table.insert(upgradeplan.shieldgroup, { path = group.path, group = group.group, count = group.shield.total, macro = chosenMacro })
			end
		end
		if #group.engine.possiblemacros > 0 then
			local chosenMacro = L.chooseMacroByRules(menu, group.engine.possiblemacros, presetTemplate.engines)
			if chosenMacro then
				table.insert(upgradeplan.enginegroup, { path = group.path, group = group.group, count = group.engine.total, macro = chosenMacro })
				for i = 1, group.engine.total do
					table.insert(upgradeplan.engine, { macro = chosenMacro })
				end
			end
		end
	end

	for type, slots in pairs(menu.slots) do
		for i, slot in ipairs(slots) do
			if not slot.isgroup and #slot.possiblemacros > 0 then
				if type == "shield" then
					local chosenMacro
					if slot.slotsize == "small" then
						chosenMacro = L.chooseMacroByRules(menu, slot.possiblemacros, presetTemplate.sshields)
					elseif slot.slotsize == "medium" then
						chosenMacro = L.chooseMacroByRules(menu, slot.possiblemacros, presetTemplate.mshields)
					elseif slot.slotsize == "large" then
						chosenMacro = L.chooseMacroByRules(menu, slot.possiblemacros, presetTemplate.lshields)
					elseif slot.slotsize == "extralarge" then
						chosenMacro = L.chooseMacroByRules(menu, slot.possiblemacros, presetTemplate.xlshields)
					else
						-- Internal shields from VRO has no slotsize and only one available macro
						chosenMacro = slot.possiblemacros[1]
					end
					if chosenMacro then
						upgradeplan.shield[i] = { macro = chosenMacro }
					end
				elseif type == "weapon" then
					local chosenMacro = L.chooseMacroByRules(menu, slot.possiblemacros, presetTemplate.weapons)
					if chosenMacro then
						upgradeplan.weapon[i] = { macro = chosenMacro }
					end
				elseif type == "engine" and #upgradeplan.enginegroup == 0 then
					local chosenMacro = L.chooseMacroByRules(menu, slot.possiblemacros, presetTemplate.engines)
					if chosenMacro then
						upgradeplan.engine[i] = { macro = chosenMacro }
					end
				elseif type == "turret" then
					local chosenMacro
					if slot.slotsize == "medium" then
						chosenMacro = L.chooseMacroByRules(menu, slot.possiblemacros, presetTemplate.mturrets)
					elseif slot.slotsize == "large" then
						chosenMacro = L.chooseMacroByRules(menu, slot.possiblemacros, presetTemplate.lturrets)
					end
					if chosenMacro then
						upgradeplan.turret[i] = { macro = chosenMacro }
					end
				elseif type == "thruster" then
					local chosenMacro = L.chooseMacroByRules(menu, slot.possiblemacros, presetTemplate.thrusters)
					if chosenMacro then
						upgradeplan.thruster[i] = { macro = chosenMacro }
					end
				end
			end
		end
	end

	if L.params.settingKey == config.shipLoadoutKey then
		if presetTemplate.software.docking.id ~= "none" then
			upgradeplan.software[1] = presetTemplate.software.docking.id
		end
		if presetTemplate.software.longrangescanner.id ~= "none" then
			upgradeplan.software[3] = presetTemplate.software.longrangescanner.id
		end
		if presetTemplate.software.objectscanner.id ~= "none" then
			upgradeplan.software[4] = presetTemplate.software.objectscanner.id
		end
		if presetTemplate.software.targeting.id ~= "none" then
			upgradeplan.software[5] = presetTemplate.software.targeting.id
		end
		if presetTemplate.software.trading.id ~= "none" then
			upgradeplan.software[6] = presetTemplate.software.trading.id
		end
		upgradeplan.software[2] = "software_flightassistmk1"
		if menu.crew then
			local crewCapacity = menu.crew.capacity
			upgradeplan.crew.service = L.getProportionateCount(crewCapacity, presetTemplate.crew.crew)
			upgradeplan.crew.marine = L.getProportionateCount(crewCapacity, presetTemplate.crew.marines)
		end
		local droneCapacity = GetMacroUnitStorageCapacity(menu.macro)
		if droneCapacity > 0 then
			upgradeplan.drone.ship_gen_xs_cargodrone_empty_01_a_macro = L.getProportionateCount(droneCapacity, presetTemplate.drones.cargo)
			if C.IsUnitMacroCompatible(menu.object, menu.macro, "ship_gen_s_miningdrone_solid_01_a_macro") then
				upgradeplan.drone.ship_gen_s_miningdrone_solid_01_a_macro = L.getProportionateCount(droneCapacity, presetTemplate.drones.mining)
			elseif C.IsUnitMacroCompatible(menu.object, menu.macro, "ship_gen_s_miningdrone_liquid_01_a_macro") then
				upgradeplan.drone.ship_gen_s_miningdrone_liquid_01_a_macro = L.getProportionateCount(droneCapacity, presetTemplate.drones.mining)
			end
			upgradeplan.drone.ship_gen_s_fightingdrone_01_a_macro = L.getProportionateCount(droneCapacity, presetTemplate.drones.defence)
			upgradeplan.drone.ship_gen_xs_repairdrone_01_a_macro = L.getProportionateCount(droneCapacity, presetTemplate.drones.repair)
		end
		local deployCapacity = C.GetMacroDeployableCapacity(menu.macro)
		if deployCapacity > 0 then
			upgradeplan.deployable.eq_arg_satellite_02_macro = L.getProportionateCount(deployCapacity, presetTemplate.deployables.advsatellite)
			upgradeplan.deployable.eq_arg_satellite_01_macro = L.getProportionateCount(deployCapacity, presetTemplate.deployables.satellite)
			upgradeplan.deployable.env_deco_nav_beacon_t1_macro = L.getProportionateCount(deployCapacity, presetTemplate.deployables.navbeacon)
			upgradeplan.deployable.eq_arg_resourceprobe_01_macro = L.getProportionateCount(deployCapacity, presetTemplate.deployables.resprobe)
			upgradeplan.deployable.ship_gen_xs_lasertower_01_a_macro = L.getProportionateCount(deployCapacity, presetTemplate.deployables.lastower1)
			upgradeplan.deployable.ship_gen_s_lasertower_01_a_macro = L.getProportionateCount(deployCapacity, presetTemplate.deployables.lastower2)
			upgradeplan.deployable.weapon_gen_mine_03_macro = L.getProportionateCount(deployCapacity, presetTemplate.deployables.ffmine)
			upgradeplan.deployable.weapon_gen_mine_01_macro = L.getProportionateCount(deployCapacity, presetTemplate.deployables.mine)
			upgradeplan.deployable.weapon_gen_mine_02_macro = L.getProportionateCount(deployCapacity, presetTemplate.deployables.trackmine)
		end
		local counterCapacity = C.GetDefaultCountermeasureStorageCapacity(menu.macro)
		if counterCapacity > 0 then
			upgradeplan.countermeasure.countermeasure_flares_01_macro = L.getProportionateCount(counterCapacity, presetTemplate.countermeasure.flares)
		end
		--C.GetMacroMissileCapacity(currentmacro)
	end

	return upgradeplan
end

function L.getProportionateCount(totalCapacity, preset)
	if not preset then
		return 0
	end
	return math.floor(totalCapacity * (preset / 100))
end

function L.chooseMacroByRules(menu, possiblemacros, rules)
	for _, rule in ipairs(rules) do
		local macro
		if rule.type == "exact" then
			macro = L.chooseMacroByExactRule(possiblemacros, rule)
		elseif rule.type == "auto" then
			macro = L.chooseMacroByAutoRule(menu, possiblemacros, rule)
		end
		if macro then
			return macro
		end
	end
	return nil
end

function L.chooseMacroByExactRule(possiblemacros, rule)
	if not rule.macro then
		return nil
	end
	for _, macro in ipairs(possiblemacros) do
		if macro == rule.macro then
			return macro
		end
	end
	return nil
end

function L.chooseMacroByAutoRule(menu, possiblemacros, rule)
	if not rule.race or not rule.value then
		return nil
	end

	-- First filter by race
	local filteredMacros = {}
	for _, macro in ipairs(possiblemacros) do
		local macroRaces, ware = GetMacroData(macro, "makerraceid", "ware")
		if rule.race == "any" or Utils.ArrayIndexOf(macroRaces, rule.race) then
			if L.params.settingKey == config.shipLoadoutKey then
				local tradelicence = GetWareData(ware, "tradelicence")
				if menu.isplayerowned or (not tradelicence) or tradelicence == "" or HasLicence("player", tradelicence, menu.containerowner) then
					table.insert(filteredMacros, { macro = macro })
				end
			else
				table.insert(filteredMacros, { macro = macro })
			end
		end
	end
	if #filteredMacros == 0 then
		return nil
	end
	-- Now sort by price and choose by rule value
	for _, macro in ipairs(filteredMacros) do
		local ware = GetMacroData(macro.macro, "ware")
		if ware then
			local price = tonumber(C.GetBuildWarePrice(menu.container, ware))
			macro.price = price
		else
			macro.price = 0
		end
	end
	table.sort(filteredMacros, function (a, b) return a.price < b.price end)
	if rule.value == "low" then
		return filteredMacros[1].macro
	elseif rule.value == "medium" then
		return filteredMacros[math.floor(#filteredMacros / 2)].macro
	elseif rule.value == "high" then
		return filteredMacros[#filteredMacros].macro
	else
		return nil
	end
end

-- Created by Eliptus
-- Edited and integrated by Runekn
function L.addPartialFlag(loadouts)
	if L.settings.item_load_partial then
		for _, loadout in ipairs(loadouts) do
			if not loadout.active then
				loadout.name = loadout.name
				loadout.active = true
				loadout.partial = true
			end
		end
	end
	return loadouts
end

-- Created by Eliptus
-- Edited and integrated by Runekn
function L.trimPartialLoadout(upgradeplan, upgradewares)
	for type,plan in pairs(upgradeplan) do
		local spec = Helper.findUpgradeType(type)
		local wares = upgradewares[type]

		local groupSuffix = "group"
		if type:sub(-#groupSuffix) == groupSuffix then
			local slotType = type:sub(1, #type - #groupSuffix)
			spec = Helper.findUpgradeType(slotType)
			wares = upgradewares[slotType]
		end

		if spec == nil or wares == nil then
			-- skip

		elseif spec.supertype == 'macro' or spec.supertype == 'virtualmacro' then
			-- plan[slot]['macro'] = macro
			for slot,info in pairs(plan) do
				if not Utils.Any(wares, function(v, _) return v.macro == info.macro end) then
					info.macro = ''
					if info.count then
						info.count = 0
					end
				end
			end

		elseif spec.supertype == 'ammo' then
			-- plan[macro] = count
			for macro,_ in pairs(plan) do
				if not Utils.Any(wares, function(v, _) return v.macro == macro end) then
					plan[macro] = 0
				end
			end

		elseif spec.supertype == 'software' then
			-- plan[slot] = ware
			for slot,ware in pairs(plan) do
				if not Utils.Any(wares, function(v, _) return v.ware == ware end) then
					plan[slot] = ''
				end
			end

		end
	end
end

return L