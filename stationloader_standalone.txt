-- ffi setup 
local ffi = require("ffi")
local C = ffi.C
 
local Lib = require("extensions.sn_mod_support_apis.lua_library")
--local RdLib = require("extensions.reactive_docking.reactivedocking")
local sc_menu = {}
local rkn_menu = {}

local sc_config = {
	contextLayer = 2,
	dropDownTextProperties = {
		halign = "center",
		font = Helper.standardFont,
		fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize),
		color = Color["text_normal"],
		x = 0,
		y = 0
	}
}

local rkn_config = {
	maxFolders = 6,
	browserHeight = 0.5 * Helper.viewHeight,
	browserSettingsWidth = Helper.scaleX(300),
	settingsBrowserSeparation = Helper.borderSize * 10,
	browserHeaderTextProperties = {
		font = Helper.headerRow1Font,
		fontsize = Helper.headerRow1FontSize,
		x = Helper.headerRow1Offsetx,
		y = math.floor((Helper.scaleY(30) - Helper.scaleY(Helper.headerRow1Height)) / 2 + Helper.scaleY(Helper.headerRow1Offsety)),
		height = Helper.scaleY(30),
		halign = "center",
		cellBGColor = Color["row_background"],
		titleColor = Color["row_title"],
	},
	folderTextProperties = {
		font = Helper.titleFont,
		fontsize = Helper.standardFontSize,
		height = Helper.subHeaderHeight,
		cellBGColor = Color["row_background"],
		titleColor = { r = 128, g = 128, b = 128, a = 100 }
	},
	planTextProperties = {

	},
	inactiveColor = { r = 128, g = 128, b = 128, a = 100 }
}

local function init()
	sc_menu = Lib.Get_Egosoft_Menu("StationConfigurationMenu")
	sc_menu.createTitleBar = rkn_menu.createTitleBar
	sc_menu.refreshTitleBar = rkn_menu.refreshTitleBar
	sc_menu.onRowChanged = rkn_menu.onRowChanged
	sc_menu.onSelectElement = rkn_menu.onSelectElement

	rkn_menu.playerID = ConvertStringTo64Bit(tostring(C.GetPlayerID()))
	rkn_menu.filter = { macros = {} }
	rkn_menu.settings = {}
end

-- Overriden function --
function rkn_menu.createTitleBar(frame)
	local menu = sc_menu
	local config = sc_config

	menu.updateConstructionPlans()
	menu.getImportablePlans()

	local ftable = frame:addTable(9, { tabOrder = 5, height = 0, x = menu.titleData.offsetX, y = menu.titleData.offsetY, scaling = false, reserveScrollBar = false })
	ftable:setColWidth(1, menu.titleData.nameWidth)
	ftable:setColWidth(2, menu.titleData.dropdownWidth)
	ftable:setColWidth(3, menu.titleData.height)
	ftable:setColWidth(4, menu.titleData.height)
	ftable:setColWidth(5, menu.titleData.height)
	ftable:setColWidth(6, menu.titleData.height)
	ftable:setColWidth(7, menu.titleData.height)
	ftable:setColWidth(8, menu.titleData.height)
	ftable:setColWidth(9, menu.titleData.height)

	local row = ftable:addRow(true, { fixed = true, bgColor = Color["row_background_blue"] })
	if not menu.loadoutMode then
		-- name
		row[1]:createEditBox({ scaling = true }):setText(ffi.string(C.GetComponentName(menu.container)), { halign = "center", font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize })
		row[1].handlers.onEditBoxDeactivated = menu.editboxNameUpdateText
		-- load
		------- Runekn's Changes Start Here! ----------
		--local loadOptions = {}
		--for _, plan in ipairs(menu.constructionplans) do
		--	table.insert(loadOptions, { id = plan.id, text = plan.name, icon = "", displayremoveoption = plan.deleteable, active = plan.active, mouseovertext = plan.mouseovertext })
		--end
		--table.sort(loadOptions, function (a, b) return a.text < b.text end)
		--row[2]:createDropDown(loadOptions, { textOverride = ReadText(1001, 7904), optionWidth = menu.titleData.dropdownWidth + menu.titleData.height + Helper.borderSize }):setTextProperties(config.dropDownTextProperties)
		--row[2].handlers.onDropDownConfirmed = menu.dropdownLoad
		--row[2].handlers.onDropDownRemoved = menu.dropdownRemovedCP

		row[2]:createButton({ helpOverlayID = "open_constructionplan_browser", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = true, height = menu.titleData.height }):setText("Load Plan", { halign = "center" })
		row[2].handlers.onClick = rkn_menu.buttonTitleLoad
		------- Runekn's Changes Stop Here! ----------
		-- save
		row[3]:createButton({ helpOverlayID = "save_constructionplan", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = true, height = menu.titleData.height, mouseOverText = ReadText(1026, 7901) }):setIcon("menu_save")
		row[3].handlers.onClick = menu.buttonTitleSave
		-- Import
		row[4]:createButton({ helpOverlayID = "import_constructionplan", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = true, height = menu.titleData.height, mouseOverText = ReadText(1026, 7916) }):setIcon("menu_import")
		row[4].handlers.onClick = menu.buttonTitleImport
		-- Export
		row[5]:createButton({ helpOverlayID = "export_constructionplan", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = true, height = menu.titleData.height, mouseOverText = ReadText(1026, 7917) }):setIcon("menu_export")
		row[5].handlers.onClick = menu.buttonTitleExport
		-- reset camera
		row[6]:createButton({ helpOverlayID = "reset_topview", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = true, height = menu.titleData.height, mouseOverText = ffi.string(C.ConvertInputString(ReadText(1026, 7911), ReadText(1026, 7902))) }):setIcon("menu_reset_view"):setHotkey("INPUT_STATE_DETAILMONITOR_RESET_VIEW", { displayIcon = false })
		row[6].handlers.onClick = function () return C.ResetMapPlayerRotation(menu.holomap) end
		-- undo
		menu.canundo = false
		if menu.holomap and (menu.holomap ~= 0) then
			menu.canundo = C.CanUndoConstructionMapChange(menu.holomap)
		end
		row[7]:createButton({ helpOverlayID = "undo_constructionplan", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = menu.canundo, height = menu.titleData.height, mouseOverText = ReadText(1026, 7903) .. Helper.formatOptionalShortcut(" (%s)", "action", 278) }):setIcon("menu_undo")
		row[7].handlers.onClick = function () return menu.undoHelper(true) end
		-- redo
		menu.canredo = false
		if menu.holomap and (menu.holomap ~= 0) then
			menu.canredo = C.CanRedoConstructionMapChange(menu.holomap)
		end
		row[8]:createButton({ helpOverlayID = "redo_constructionplan", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = menu.canredo, height = menu.titleData.height, mouseOverText = ReadText(1026, 7904) .. Helper.formatOptionalShortcut(" (%s)", "action", 279) }):setIcon("menu_redo")
		row[8].handlers.onClick = function () return menu.undoHelper(false) end
		-- settings
		row[9]:createButton({ helpOverlayID = "settings", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = true, height = menu.titleData.height }):setIcon("menu_options")
		row[9].handlers.onClick = menu.buttonTitleSettings
	else
		-- name
		row[1]:createEditBox({ scaling = true }):setText(ffi.string(C.GetComponentName(menu.container)), { halign = "center", font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize })
		row[1].handlers.onEditBoxDeactivated = menu.editboxNameUpdateText
		-- load
		local loadoutOptions = {}
		if next(menu.loadouts) then
			for _, loadout in ipairs(menu.loadouts) do
				table.insert(loadoutOptions, { id = loadout.id, text = loadout.name, icon = "", displayremoveoption = loadout.deleteable, active = loadout.active, mouseovertext = loadout.mouseovertext })
			end
		end
		row[2]:setColSpan(6):createDropDown(loadoutOptions, { textOverride = ReadText(1001, 7905), optionWidth = menu.titleData.dropdownWidth + 6 * (menu.titleData.height + Helper.borderSize) }):setTextProperties(config.dropDownTextProperties)
		row[2].handlers.onDropDownConfirmed = menu.dropdownLoadout
		row[2].handlers.onDropDownRemoved = menu.dropdownRemovedLoadout
		-- save
		row[8]:createButton({ helpOverlayID = "save_loadout", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = true, height = menu.titleData.height, mouseOverText = ReadText(1026, 7905) }):setIcon("menu_save")
		row[8].handlers.onClick = menu.buttonTitleSaveLoadout
		-- reset camera
		row[9]:createButton({ helpOverlayID = "reset_topview", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = true, height = menu.titleData.height, mouseOverText = ffi.string(C.ConvertInputString(ReadText(1026, 7911), ReadText(1026, 7902))) }):setIcon("menu_reset_view"):setHotkey("INPUT_STATE_DETAILMONITOR_RESET_VIEW", { displayIcon = false })
		row[9].handlers.onClick = function () return C.ResetMapPlayerRotation(menu.holomap) end
	end
end

-- Overriden function --
function rkn_menu.refreshTitleBar()
	local menu = sc_menu
	local config = sc_config

	local text = {
		alignment = "center",
		fontname = Helper.standardFont,
		fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize),
		color = Color["text_normal"],
		x = 0,
		y = 0
	}

	menu.updateConstructionPlans()
	menu.getImportablePlans()

	if not menu.loadoutMode then
		--text.override = ReadText(1001, 7904)
		--local loadOptions = {}
		--for _, plan in ipairs(menu.constructionplans) do
			--table.insert(loadOptions, { id = plan.id, text = plan.name, icon = "", displayremoveoption = plan.deleteable, active = plan.active, mouseovertext = plan.mouseovertext })
		--end
		--table.sort(loadOptions, function (a, b) return a.text < b.text end)

		-- editbox
		local desc = Helper.createEditBox(Helper.createTextInfo(ffi.string(C.GetComponentName(menu.container)), "center", Helper.headerRow1Font, Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize), 255, 255, 255, 100), true, 0, 0, 0, 0, nil, nil, false)
		Helper.setCellContent(menu, menu.titlebartable, desc, 1, 1, nil, "editbox", nil, menu.editboxNameUpdateText)
		-- dropdown
		------- Runekn's Changes Start Here! ----------
		--local desc = Helper.createDropDown(loadOptions, "", text, nil, true, true, 0, 0, 0, 0, nil, nil, "", menu.titleData.dropdownWidth + menu.titleData.height + Helper.borderSize)
		--Helper.setCellContent(menu, menu.titlebartable, desc, 1, 2, nil, "dropdown", nil, nil, menu.dropdownLoad, menu.dropdownRemovedCP)

		local desc = Helper.createButton(Helper.createTextInfo("Load Plan", "center", Helper.standardFont, Helper.standardFontSize, 255, 255, 255, 100), nil, true, true, 0, 0, 0, menu.titleData.height, nil, nil, nil, "")
		Helper.setCellContent(menu, menu.titlebartable, desc, 1, 2, nil, "button", nil, rkn_menu.buttonTitleLoad)
		------- Runekn's Changes Stop Here! ----------
		-- save
		local desc = Helper.createButton(nil, Helper.createButtonIcon("menu_save", nil, 255, 255, 255, 100), true, true, 0, 0, 0, menu.titleData.height, nil, nil, nil, ReadText(1026, 7901))
		Helper.setCellContent(menu, menu.titlebartable, desc, 1, 3, nil, "button", nil, menu.buttonTitleSave)
	else
		text.override = ReadText(1001, 7905)
		local loadoutOptions = {}
		if next(menu.loadouts) then
			for _, loadout in ipairs(menu.loadouts) do
				table.insert(loadoutOptions, { id = loadout.id, text = loadout.name, icon = "", displayremoveoption = loadout.deleteable, active = loadout.active, mouseovertext = loadout.mouseovertext })
			end
		end

		-- editbox
		local desc = Helper.createEditBox(Helper.createTextInfo(ffi.string(C.GetComponentName(menu.container)), "center", Helper.headerRow1Font, Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize), 255, 255, 255, 100), true, 0, 0, 0, 0, nil, nil, false)
		Helper.setCellContent(menu, menu.titlebartable, desc, 1, 1, nil, "editbox", nil, menu.editboxNameUpdateText)
		-- dropdown
		local desc = Helper.createDropDown(loadoutOptions, "", text, nil, true, next(menu.loadouts) ~= nil, 0, 0, 0, 0, nil, nil, "", menu.titleData.dropdownWidth + 4 * (menu.titleData.height + Helper.borderSize))
		Helper.setCellContent(menu, menu.titlebartable, desc, 1, 2, nil, "dropdown", nil, nil, menu.dropdownLoadout, menu.dropdownRemovedLoadout)
		-- save
		local desc = Helper.createButton(nil, Helper.createButtonIcon("menu_save", nil, 255, 255, 255, 100), true, true, 0, 0, 0, menu.titleData.height, nil, nil, nil, ReadText(1026, 7905))
		Helper.setCellContent(menu, menu.titlebartable, desc, 1, 8, nil, "button", nil, menu.buttonTitleSaveLoadout)
	end
end

-- Overriden function --
function rkn_menu.onRowChanged(row, rowdata, uitable, modified, input, source)
	local menu = sc_menu

	if not menu.loadoutMode then
		-- Runekn's Changes Start Here! --
		if rkn_menu.ltable and uitable == rkn_menu.ltable.id then
			rkn_menu.selectedEntry = rowdata
			return
		else
			rkn_menu.selectedEntry = nil
		end
		-- Runekn's Changes Stop Here! --
		if uitable == menu.plantable then
			if menu.holomap ~= 0 then
				if (source ~= "auto") or (menu.selectedModule == nil) then
					if (type(rowdata) == "table") and rowdata.ismodule and (not rowdata.removed) then
						menu.newSelectedModule = rowdata.module
						C.SelectBuildMapEntry(menu.holomap, rowdata.idx)
					elseif menu.selectedModule ~= nil then
						menu.newSelectedModule = "clear"
						C.ClearBuildMapSelection(menu.holomap)
					end
				end
			end
		elseif uitable == menu.contexttable then
			if (source ~= "auto") or (menu.contextData and (menu.contextData.selectedEntry == nil)) then
				if (type(rowdata) == "table") then
					menu.contextData.newSelectedEntry = rowdata
				end
			end
		end
	end
end

-- Overriden function --
function rkn_menu.onSelectElement(uitable, modified, row)
	local menu = sc_menu

	if uitable == menu.plantable then
		if menu.holomap ~= 0 then
			if (source ~= "auto") or (menu.selectedModule == nil) then
				local rowdata = Helper.getCurrentRowData(menu, uitable)
				if (type(rowdata) == "table") and rowdata.ismodule and (not rowdata.removed) then
					C.SetFocusMapConstructionPlanEntry(menu.holomap, rowdata.idx, true)
				end
			end
		end
	-- Runekn's Changes Start Here! --
	elseif uitable == rkn_menu.ltable.id then
		rkn_menu.buttonLoadPlan()
	-- Runekn's Changes Stop Here! --
	end
end



function rkn_menu.buttonTitleLoad()
	if sc_menu.contextMode and (sc_menu.contextMode.mode == "loadCP") then
		sc_menu.closeContextMenu()
	else
		rkn_menu.createCPBrowserContext();
	end
end

function rkn_menu.createCPBrowserContext()
	rkn_menu.settings = rkn_menu.getBrowserSettings("station")
	local listRoot = rkn_menu.prepareBrowserStructure(sc_menu.constructionplans)

	sc_menu.displayContextFrame("loadCP", sc_menu.titleData.width, sc_menu.titleData.offsetX, sc_menu.titleData.offsetY + sc_menu.titleData.height + Helper.borderSize)
	Helper.removeAllWidgetScripts(sc_menu, sc_config.contextLayer)

	sc_menu.contextFrame = Helper.createFrameHandle(sc_menu, {
		layer = sc_config.contextLayer,
		standardButtons = {},
		width = sc_menu.contextMode.width,
		x = sc_menu.contextMode.x,
		y = sc_menu.contextMode.y,
		autoFrameHeight = true,
	})
	sc_menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local smallColWidth = Helper.scaleY(Helper.standardTextHeight)
	local browserWidth = sc_menu.contextMode.width - rkn_config.browserSettingsWidth - Helper.borderSize * 2 - rkn_config.settingsBrowserSeparation
	local browserX = rkn_config.browserSettingsWidth + Helper.borderSize + rkn_config.settingsBrowserSeparation

	-- Create item list --
	local ltable = sc_menu.contextFrame:addTable(rkn_config.maxFolders + 1, { tabOrder = 6, reserveScrollBar = true, maxVisibleHeight = rkn_config.browserHeight - Helper.standardButtonHeight, x = browserX, width = browserWidth })
	for column = 1, rkn_config.maxFolders do
		ltable:setColWidth(column, smallColWidth, false)
	end
	rkn_menu.ltable = ltable
	local row = ltable:addRow(false, { fixed = true })
	row[1]:setColSpan(rkn_config.maxFolders + 1):createText("Load Construction Plan", rkn_config.browserHeaderTextProperties)

	rkn_menu.addFolderToList(ltable, listRoot, 1)

	ltable:setTopRow(sc_menu.topRows.rkn_configbrowser_load)
	ltable:setSelectedRow(sc_menu.selectedRows.rkn_configbrowser_load)

	-- Create list buttons --
	local tableColumns = 5
	local btable = sc_menu.contextFrame:addTable(5, { tabOrder = 5, reserveScrollBar = false, highlightMode = "off", y = rkn_config.browserHeight - Helper.standardButtonHeight, x = browserX, width = browserWidth })
	rkn_menu.btable = btable
	local row = btable:addRow(true, { fixed = true })
	row[tableColumns-2]:createButton({ active = rkn_menu.isRowValidForDeletion }):setText("Delete", { halign = "center" })
	row[tableColumns-2].handlers.onClick = rkn_menu.buttonDeletePlan
	row[tableColumns-1]:createButton({ active = rkn_menu.isRowValidForLoad }):setText("Load", { halign = "center" })
	row[tableColumns-1].handlers.onClick = rkn_menu.buttonLoadPlan
	row[tableColumns]:createButton({  }):setText("Cancel", { halign = "center" })
	row[tableColumns].handlers.onClick = sc_menu.closeContextMenu

	-- Create settings list --
	local stable = sc_menu.contextFrame:addTable(2, { tabOrder = 6, maxVisibleHeight = rkn_config.browserHeight, x = Helper.borderSize, width = rkn_config.browserSettingsWidth - Helper.borderSize * 2 })
	stable:setColWidth(1, rkn_config.browserSettingsWidth * 0.7, false)
	local row = stable:addRow(false, { fixed = true })
	row[1]:setColSpan(2):createText("Settings", rkn_config.browserHeaderTextProperties)

	local row = stable:addRow(true, { fixed = true })
	row[1]:createText("Enable folders", { })
	row[2]:createCheckBox(rkn_menu.settings.folder_enabled, { width = smallColWidth })
	row[2].handlers.onClick = rkn_menu.folderEnabledToggled
	
	local row = stable:addRow(false, { fixed = true }) -- bit of separation
	row[1]:createText("", { })

	local row = stable:addRow(true, { fixed = true })
	row[1]:createText("Folder delimiter", { })
	local delimiterEditBoxText = rkn_menu.settings.folder_delimiter:gsub(" ", "(space)") -- Replace spaces with '(space)' so that it is easier to read
	row[2]:createEditBox({ scaling = true }):setText(delimiterEditBoxText, { })
	row[2].handlers.onEditBoxDeactivated = rkn_menu.folderDelimiterEdit
	row[2].properties.mouseOverText = "The character that the browser should split item names by to create folders. Only one character allowed."
	row[2].properties.active = rkn_menu.settings.folder_enabled

	local row = stable:addRow(true, { fixed = true })
	row[1]:createText("Display full item name", { })
	row[2]:createCheckBox(rkn_menu.settings.item_fullname, { width = smallColWidth })
	row[2].handlers.onClick = rkn_menu.itemFullnameToggled
	row[2].properties.active = rkn_menu.settings.folder_enabled

	local row = stable:addRow(true, { fixed = true })
	row[1]:createText("Display full folder name", { })
	row[2]:createCheckBox(rkn_menu.settings.folder_fullname, { width = smallColWidth })
	row[2].handlers.onClick = rkn_menu.folderFullnameToggled
	row[2].properties.active = rkn_menu.settings.folder_enabled

	local row = stable:addRow(true, { fixed = true })
	row[1]:createText("Single item folder", { })
	row[2]:createCheckBox(rkn_menu.settings.folder_single_item, { width = smallColWidth })
	row[2].handlers.onClick = rkn_menu.folderSingleItemToggled
	row[2].properties.mouseOverText = "Allow folders that only contain one item."
	row[2].properties.active = rkn_menu.settings.folder_enabled

	-- Search bar --
	local row = stable:addRow(false, { fixed = true })
	row[1]:setColSpan(2):createText("Search", rkn_config.browserHeaderTextProperties)

	local row = stable:addRow(true, { fixed = true })
	row[1]:createEditBox({ scaling = true, height = Helper.standardButtonHeight }):setText(rkn_menu.filter.search, { })
	row[1].handlers.onEditBoxDeactivated = rkn_menu.searchItemEdit
	row[2]:createButton({  }):setText("Clear", { halign = "center" })
	row[2].handlers.onClick = function () rkn_menu.searchItemEdit(nil, "", true) end

	-- Module filter --
	local row = stable:addRow(false, { fixed = true })
	row[1]:setColSpan(2):createText("Module filter", rkn_config.browserHeaderTextProperties)

	local addSeparation = rkn_menu.addModulesToFilter(stable, "Remove", true)
	if addSeparation then
		local row = stable:addRow(false, { }) -- bit of separation
		row[1]:createText("", { height = Helper.standardButtonHeight })
	end
	rkn_menu.addModulesToFilter(stable, "Add", false)

	sc_menu.contextFrame:display()
end

function rkn_menu.prepareBrowserStructure(itemList)
	-- First we build the folder structure --
	local root = { type = "folder", name = "root", folders = {}, folders_arr = {}, items = {} }
	for _, item in ipairs(itemList) do
		if not rkn_menu.filterItem(item) then
			goto continue
		end
		local cwd = root
		-- iterate through item folders --
		local nextMatch = string.gmatch(item.name, "[^" .. EscapeGmatch(rkn_menu.settings.folder_delimiter) .. "]+")
		local folder = nextMatch()
		local name = item.name
		local levelsLeft = rkn_menu.settings.folder_enabled and rkn_config.maxFolders or 0
		local folderPath = ""
		while 1==1 do
			-- Check if this is the item name --
			local next = nextMatch()
			if not next then
				name = folder
				break
			end
			levelsLeft = levelsLeft -1
			if levelsLeft <= 0 then
				-- Make the rest of the actual item name, the displayed name --
				name = item.name:sub(folderPath:len())
				break
			end
			-- Otherwise, path to folder --
			folderPath = folderPath .. "/" .. folder
			local target = cwd.folders[folder]
			if not target then
				target = { type = "folder", name = folder, fullname = folderPath, folders = {}, folders_arr = {}, items = {} }
				cwd.folders[folder] = target
				table.insert(cwd.folders_arr, target)
			end
			cwd = target
			folder = next
		end
		table.insert(cwd.items, { type = "item", name = name, active = item.active, deleteable = item.deleteable, item = item })
		::continue::
	end

	if not rkn_menu.settings.folder_single_item then
		rkn_menu.undentSingleItems(root)
	end

	-- Now we sort all folders --
	rkn_menu.sortFolder(root)

	return root
end

function rkn_menu.filterItem(item)
	if rkn_menu.filter.macros and CountArray(rkn_menu.filter.macros) > 0 then
		local hasmacros = Helper.textArrayHelper(rkn_menu.filter.macros, function (numtexts, texts) return C.CheckConstructionPlanForMacros(item.id, texts, numtexts) end)
		if not hasmacros then
			return false
		end
	end
	if rkn_menu.filter.search and rkn_menu.filter.search ~= "" then
		local searchMatch = item.name:find(rkn_menu.filter.search)
		if not searchMatch then
			return false
		end
	end
	return true
end

function rkn_menu.undentSingleItems(folder, parent)
	local canDelete = true
	local atLeastOneSubFolder = false
	-- recursive --
	ArrayRemove(folder.folders_arr, function(t, i, j)
		local subfolder = folder.folders_arr[i];
		local keepSubFolder = rkn_menu.undentSingleItems(subfolder, folder)
		canDelete = canDelete and not keepSubFolder
		atLeastOneSubFolder = atLeastOneSubFolder or keepSubFolder
		return keepSubFolder
	end);

	-- move item to parent if there is only one --
	local itemCount = CountArray(folder.items)
	if itemCount == 1 and not atLeastOneSubFolder and parent then
		local item = folder.items[1]

		table.insert(parent.items, item)
		table.remove(folder.items, 1)

		item.name = folder.name .. rkn_menu.settings.folder_delimiter .. item.name
	elseif itemCount > 1 then
		canDelete = false
	end
	return not canDelete
end

function rkn_menu.sortFolder(folder)
	table.sort(folder.items, function (a, b) return a.name < b.name end)
	table.sort(folder.folders_arr, function (a, b) return a.name < b.name end)
	for _, innerFolder in ipairs(folder.folders_arr) do
		rkn_menu.sortFolder(innerFolder)
	end
end

function rkn_menu.addFolderToList(ltable, root, column)
	for _, folder in ipairs(root.folders_arr) do
		local row = ltable:addRow(folder, {  })
		local folderId = "rkn_configbrowser_folder_" .. folder.fullname
		local isextended = sc_menu.isResourceEntryExtended(folderId)
		row[column]:createButton({ helpOverlayID = folderId, helpOverlayText = " ",  helpOverlayHighlightOnly = true }):setText(isextended and "-" or "+", { halign = "center" })
		row[column].handlers.onClick = function () return rkn_menu.buttonExtendListEntry(folderId, row.index) end
		local text = rkn_menu.settings.folder_fullname and folder.fullname or folder.name
		row[column + 1]:setColSpan(rkn_config.maxFolders - column + 1):createText(text, rkn_config.folderTextProperties)
		if isextended then
			rkn_menu.addFolderToList(ltable, folder, column + 1)
		end
	end

	for _, item in ipairs(root.items) do
		local row = ltable:addRow(item, {  })
		local text = rkn_menu.settings.item_fullname and item.item.name or item.name
		if not item.active then
			text = Helper.convertColorToText(rkn_config.inactiveColor) .. text
		end
		row[column]:setColSpan(rkn_config.maxFolders - column + 2):createText(text, rkn_config.planTextProperties)
	end
end

function rkn_menu.addModulesToFilter(table, buttonText, checked)
	local atLeastOneAdded = false;
	for _, macro in ipairs(sc_menu.modules["moduletypes_production"]) do
		if (checked and ArrayIndexOf(rkn_menu.filter.macros, macro) ~= nil) or (not checked and ArrayIndexOf(rkn_menu.filter.macros, macro) == nil) then
			local row = table:addRow(true, { })
			local name = GetMacroData(macro, "name")
			row[1]:createText(name, { })
			row[2]:createButton({  }):setText(buttonText, { halign = "center" })
			row[2].handlers.onClick = function () rkn_menu.filterMacroToggled(macro, not checked) end
			atLeastOneAdded = true
		end
	end
	return atLeastOneAdded
end

function rkn_menu.isRowValidForLoad()
	return rkn_menu.selectedEntry and rkn_menu.selectedEntry.active
end

function rkn_menu.isRowValidForDeletion()
	return rkn_menu.selectedEntry and rkn_menu.selectedEntry.deleteable
end

function rkn_menu.buttonDeletePlan()
	if rkn_menu.isRowValidForDeletion then
		sc_menu.dropdownRemovedCP(nil, rkn_menu.selectedEntry.item.id)
	end
end

function rkn_menu.buttonLoadPlan()
	if rkn_menu.isRowValidForLoad then
		sc_menu.dropdownLoad(nil, rkn_menu.selectedEntry.item.id)
	end
end

function rkn_menu.buttonExtendListEntry(index, row)
	sc_menu.extendResourceEntry(index)

	sc_menu.topRows.rkn_configbrowser_load = GetTopRow(sc_menu.contexttable)
	sc_menu.selectedRows.rkn_configbrowser_load = row

	rkn_menu.createCPBrowserContext();
end

function rkn_menu.settingChanged(k, v)
	--DebugError("rkn_menu.settingChanged(" .. k .. ", " .. tostring(v) .. ")")
	rkn_menu.setBrowserSetting("station", k, v)
	sc_menu.topRows.rkn_configbrowser_load = GetTopRow(sc_menu.contexttable)
	rkn_menu.createCPBrowserContext()
end

function rkn_menu.folderEnabledToggled(_, checked)
	rkn_menu.settingChanged("folder_enabled", checked)
end

function rkn_menu.itemFullnameToggled(_, checked)
	rkn_menu.settingChanged("item_fullname", checked)
end

function rkn_menu.folderFullnameToggled(_, checked)
	rkn_menu.settingChanged("folder_fullname", checked)
end

function rkn_menu.folderSingleItemToggled(_, checked)
	rkn_menu.settingChanged("folder_single_item", checked)
end

function rkn_menu.folderDelimiterEdit(_, text, textchanged)
	if not textchanged then
		return
	end

	text = text:gsub("(space)", " ")
	if text:len() > 1 then
		text = text:sub(1, 1)
	end
	rkn_menu.settingChanged("folder_delimiter", text)
end

function rkn_menu.searchItemEdit(_, text, textchanged)
	if not textchanged then
		return
	end

	rkn_menu.filter.search = text
	sc_menu.topRows.rkn_configbrowser_load = GetTopRow(sc_menu.contexttable)
	rkn_menu.createCPBrowserContext()
end

function rkn_menu.filterMacroToggled(macro, checked)
	if checked then
		table.insert(rkn_menu.filter.macros, macro)
	else
		local index = ArrayIndexOf(rkn_menu.filter.macros, macro)
		if index then
			table.remove(rkn_menu.filter.macros, index)
		end
	end
	sc_menu.topRows.rkn_configbrowser_load = GetTopRow(sc_menu.contexttable)
	rkn_menu.createCPBrowserContext()
end

function rkn_menu.getBrowserSettings(browser)
	local s = GetNPCBlackboard(rkn_menu.playerID, "$rkn_configbrowser_settings_" .. browser)
	if not s then
		return {
			folder_enabled = false,
			folder_delimiter = " ",
			folder_single_item = false,
			folder_fullname = false,
			item_fullname = true
		}
	end
	return {
		folder_enabled = s.folder_enabled == 1,
		folder_delimiter = (not s.folder_delimiter or s.folder_delimiter == "") and " " or s.folder_delimiter,
		folder_single_item = s.folder_single_item == 1,
		folder_fullname = s.folder_fullname == 1,
		item_fullname = s.item_fullname == 1
	}
end

function rkn_menu.setBrowserSetting(browser, key, value)
	local settings = rkn_menu.getBrowserSettings(browser)
	settings[key] = value
	SetNPCBlackboard(rkn_menu.playerID, "$rkn_configbrowser_settings_" .. browser, settings)
end

function CountArray(arr)
	local count = 0
	for _ in pairs(arr) do count = count + 1 end
	return count
end

function EscapeGmatch(s)
    return (s:gsub('[%-%.%+%[%]%(%)%$%^%%%?%*]','%%%1'))
end

function ArrayRemove(t, fnKeep)
    local j, n = 1, #t;

    for i=1,n do
        if (fnKeep(t, i, j)) then
            -- Move i's kept value to j's position, if it's not already there.
            if (i ~= j) then
                t[j] = t[i];
                t[i] = nil;
            end
            j = j + 1; -- Increment position of where we'll place the next kept value.
        else
            t[i] = nil;
        end
    end

    return t;
end

function ArrayIndexOf(arr, v)
	if not arr then
		return nil
	end
	for i, m in ipairs(arr) do
		if m == v then
			return i
		end
	end
	return nil
end

-- For debugging --
function DebugSettings()
	local settings = GetNPCBlackboard(rkn_menu.playerID, "$rkn_configbrowser_settings_station")
	DebugError(string.format("{\n  folder_enabled = %s,\n  folder_delimiter = %s,\n  folder_single_item = %s,\n  folder_fullname = %s,\n  item_fullname = %s }",
		tostring(settings.folder_enabled),
		tostring(settings.folder_delimiter),
		tostring(settings.folder_single_item),
		tostring(settings.folder_fullname),
		tostring(settings.item_fullname)
	))
end

-- For debugging --
function SerializeTable(val, name, skipnewlines, depth)
    skipnewlines = skipnewlines or false
    depth = depth or 0

    local tmp = string.rep(" ", depth)

    if name then tmp = tmp .. name .. " = " end

    if type(val) == "table" then
        tmp = tmp .. "{" .. (not skipnewlines and "\n" or "")

        for k, v in pairs(val) do
            tmp =  tmp .. SerializeTable(v, k, skipnewlines, depth + 1) .. "," .. (not skipnewlines and "\n" or "")
        end

        tmp = tmp .. string.rep(" ", depth) .. "}"
    elseif type(val) == "number" then
        tmp = tmp .. tostring(val)
    elseif type(val) == "string" then
        tmp = tmp .. string.format("%q", val)
    elseif type(val) == "boolean" then
        tmp = tmp .. (val and "true" or "false")
    else
        tmp = tmp .. "\"[inserializeable datatype:" .. type(val) .. "]\""
    end

    return tmp
end



init()